{
  "enabled": true,
  "name": "Criador e Ajustador de Testes",
  "description": "Analisa diff da branch atual vs main para criar/ajustar testes focados em comportamento. Prioriza testes de interface (isVisible, clicks, interaÃ§Ãµes). Garante confiabilidade e aderÃªncia Ã s regras sem testes superficiais.",
  "version": "3.2",
  "when": {
    "type": "userTriggered"
  },
  "then": {
    "type": "askAgent",
    "prompt": "VocÃª Ã© **especialista em testes de software (Frontend Vue 3 + TypeScript)**, atuando como **DEV SÃªnior**.\n\nSiga: **1_code-style.md**, **2_kiro-guide.md** e **7_testing-best-practices.md**.\n\nğŸš« **NUNCA refatore cÃ³digo de produÃ§Ã£o para facilitar testes.**\nğŸš« **NUNCA teste o framework - teste apenas SEU cÃ³digo.**\n\n## ğŸ¯ MISSÃƒO - EXECUTE PASSO A PASSO\n\n### PASSO 1: IDENTIFICAR MUDANÃ‡AS\n\n1. Execute: `git diff main --name-status`\n2. Filtre APENAS arquivos `.ts` e `.vue` dentro de `src/`\n3. Exclua arquivos de teste (`*.spec.ts`, `__tests__/`)\n4. Classifique: ğŸ†• Novo (A), âœï¸ Alterado (M), ğŸ—‘ï¸ Removido (D)\n5. **Liste os arquivos encontrados e aguarde confirmaÃ§Ã£o antes de prosseguir**\n\n### PASSO 2: APLICAR REGRAS\n\nPara cada arquivo:\n\n**ğŸ†• Arquivo NOVO:**\n- Leia o arquivo\n- Se possuir lÃ³gica (mÃ©todos, computed, funÃ§Ãµes): Criar teste (cobertura 100%)\n- Se nÃ£o possuir lÃ³gica (apenas DTO, export de constantes): NÃ£o criar teste\n\n**âœï¸ Arquivo ALTERADO:**\n- Verifique se existe teste em `NomeDoArquivo.spec.ts` (co-localizado)\n- Se jÃ¡ possui teste: Ajustar para novo comportamento\n- Se nÃ£o possui teste: **NÃƒO criar novos testes**\n\n**ğŸ—‘ï¸ Arquivo REMOVIDO:**\n- Remover teste correspondente se existir\n\n### PASSO 3: CRIAR/AJUSTAR TESTES\n\nPara cada arquivo que precisa de teste:\n\n**Se CRIAR (arquivo novo):**\n1. Leia o arquivo fonte completamente\n2. Identifique: mÃ©todos, computed, props, events, lÃ³gica\n3. Crie teste seguindo estrutura:\n\n```typescript\nimport { describe, it, expect, beforeEach, vi } from 'vitest'\nimport { mount } from '@vue/test-utils'\nimport ComponentName from './ComponentName.vue'\n\ndescribe('ComponentName.vue', () => {\n  let wrapper\n\n  beforeEach(() => {\n    vi.clearAllMocks()\n    wrapper = mount(ComponentName, {\n      props: {}\n    })\n  })\n\n  // Testes aqui\n})\n```\n\n4. Cobertura 100% da tag `<script>`\n\n**Se AJUSTAR (arquivo alterado):**\n1. Leia o arquivo fonte modificado\n2. Leia o teste existente\n3. Identifique o que mudou (novos mÃ©todos, computed removidos, props alteradas)\n4. Atualize testes existentes\n5. Adicione testes para novos comportamentos\n6. Remova testes obsoletos\n\n### PASSO 4: FILOSOFIA DE TESTES\n\n**âœ… SEMPRE Teste:**\n- LÃ³gica de negÃ³cio, mÃ©todos, computed com lÃ³gica\n- **Interface (isVisible, clicks, inputs, valores exibidos)**\n- **Elementos visÃ­veis vs ocultos**\n- **Classes CSS e atributos dinÃ¢micos**\n\n**âŒ NUNCA Teste:**\n- Framework (Vue, Vuetify)\n- Props que apenas passam valores\n- ExistÃªncia sem comportamento (`exists()` sozinho)\n\n### PASSO 5: PRIORIDADE DE TESTES\n\n1. ğŸ¨ **Teste pela interface** (o que usuÃ¡rio vÃª)\n2. ğŸ”¬ **Teste pela lÃ³gica** (quando interface nÃ£o aplicar)\n3. ğŸ”„ **Teste ambos** (ideal)\n\n**Exemplos:**\n\n```typescript\n// âœ… MELHOR - Interface\nit('Deve exibir modal quando clicar no botÃ£o', async () => {\n  await wrapper.find('[data-testid=\"btn-open\"]').trigger('click')\n  expect(wrapper.findComponent(ExpenseFormDialog).isVisible()).toBe(true)\n})\n\n// âœ… MELHOR - Propriedade pela interface\nit('Deve aplicar classe active quando despesa estiver selecionada', async () => {\n  await wrapper.setProps({ selected: true })\n  expect(wrapper.find('.expense-item').classes()).toContain('active')\n})\n```\n\n### PASSO 6: REGRA DE OURO\n\n**`isVisible()` para validar visualizaÃ§Ã£o:**\n```typescript\n// âœ… CORRETO\nexpect(button.isVisible()).toBe(true)\n\n// âŒ INCORRETO\nexpect(button.exists()).toBe(true) // Pode estar oculto!\n```\n\n**`exists()` apenas para presenÃ§a no DOM (v-if):**\n```typescript\n// âœ… CORRETO - v-if\nexpect(button.exists()).toBe(false)\n```\n\n### PASSO 7: INTERAÃ‡Ã•ES\n\n**Prioridade: InteraÃ§Ã£o > MÃ©todo Direto**\n\n```typescript\n// âœ… MELHOR\nit('Deve salvar quando clicar no botÃ£o', async () => {\n  await wrapper.find('[data-testid=\"input-name\"]').setValue('Aluguel')\n  await wrapper.find('[data-testid=\"btn-save\"]').trigger('click')\n  expect(mockApi.save).toHaveBeenCalledWith({ name: 'Aluguel' })\n})\n```\n\n### PASSO 8: NOMENCLATURA\n\n**PadrÃ£o: \"Deve... quando...\"**\n\n```typescript\n// âœ… CORRETO\nit('Deve formatar valor como moeda quando receber nÃºmero', () => {})\nit('Deve desabilitar botÃ£o quando nÃ£o houver ID', () => {})\nit('NÃ£o deve chamar API quando formulÃ¡rio estiver invÃ¡lido', () => {})\n```\n\n### PASSO 9: VALIDAÃ‡ÃƒO\n\n- `.toEqual()`: Adapters, contratos crÃ­ticos\n- `.toMatchObject()`: Campos crÃ­ticos\n- `.toBe(true/false)`: Booleanos (NUNCA toBeTruthy/toBeFalsy)\n\n```typescript\n// âœ… CORRETO\nexpect(button.attributes('disabled')).toBe(true)\n\n// âŒ INCORRETO\nexpect(button.attributes('disabled')).toBeTruthy()\n```\n\n### PASSO 10: DRY\n\n**Use `it.each` para 3+ testes similares:**\n\n```typescript\nconst cases = [\n  { description: 'Deve retornar \"-\" quando null', input: null, expected: '-' },\n  { description: 'Deve formatar \"123\" como \"R$ 123,00\"', input: 123, expected: 'R$ 123,00' }\n]\n\nit.each(cases)('$description', async ({ input, expected }) => {\n  await wrapper.setProps({ value: input })\n  expect(wrapper.vm.formattedValue).toBe(expected)\n})\n```\n\n### PASSO 11: EXECUTAR TESTES\n\n1. Execute: `npm run test`\n2. Se FALHAR:\n   - Analise os erros\n   - Corrija os testes\n   - Execute novamente\n3. Se PASSAR: Prossiga para resumo\n\n### PASSO 12: RESUMO FINAL\n\nApresente:\n- âœ… Arquivos modificados encontrados (quantidade)\n- ğŸ†• Testes criados (lista de arquivos)\n- âœï¸ Testes ajustados (lista de arquivos)\n- ğŸ—‘ï¸ Testes removidos (lista de arquivos)\n- ğŸ§ª Status dos testes (passou/falhou)\n\n### CHECKLIST DE QUALIDADE\n\n- [ ] Teste quebra se regra mudar?\n- [ ] Sobrevive a refatoraÃ§Ãµes?\n- [ ] Nome claro?\n- [ ] Testo MEU cÃ³digo, nÃ£o framework?\n- [ ] Usei `isVisible()` para visualizaÃ§Ã£o?\n- [ ] Testei pela interface quando possÃ­vel?\n- [ ] Usei `.toBe(true/false)` para booleanos?\n\n**Se NÃƒO, teste invÃ¡lido.**\n\nğŸš« **Nunca crie testes para inflar cobertura.**\n\n**EXECUTE PASSO 1 AGORA!**"
  },
  "workspaceFolderName": "frontend",
  "shortName": "unit-test-checker"
}